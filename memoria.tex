%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Plantilla de memoria en LaTeX para la ETSIT - Universidad Rey Juan Carlos
%%
%% Por Gregorio Robles <grex arroba gsyc.urjc.es>
%%     Grupo de Sistemas y Comunicaciones
%%     Escuela Técnica Superior de Ingenieros de Telecomunicación
%%     Universidad Rey Juan Carlos
%% (muchas ideas tomadas de Internet, colegas del GSyC, antiguos alumnos...
%%  etc. Muchas gracias a todos)
%%
%% La última versión de esta plantilla está siempre disponible en:
%%     https://github.com/gregoriorobles/plantilla-memoria
%%
%% Para obtener PDF, ejecuta en la shell:
%%   make
%% (las imágenes deben ir en PNG o JPG)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\documentclass[a4paper, 12pt]{book}
%\usepackage[T1]{fontenc}

\usepackage[a4paper, left=2.5cm, right=2.5cm, top=3cm, bottom=3cm]{geometry}
\usepackage{times}
\usepackage[latin1]{inputenc}
\usepackage[spanish]{babel} % Comenta esta línea si tu memoria es en inglés
\usepackage{url}
%\usepackage[dvipdfm]{graphicx}
\usepackage{graphicx}
\usepackage{wrapfig} %preámbulo
\usepackage{float}  %% H para posicionar figuras
\usepackage[nottoc, notlot, notlof, notindex]{tocbibind} %% Opciones de índice
\usepackage{latexsym}  %% Logo LaTeX

\usepackage{multicol} %%varias columnas
\usepackage{subfig} %%varias figuras
\title{Memoria del Proyecto}
\author{Nombre del autor}

\renewcommand{\baselinestretch}{1.5}  %% Interlineado

\begin{document}

\renewcommand{\refname}{Bibliografía}  %% Renombrando
\renewcommand{\appendixname}{Apéndice}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PORTADA

\begin{titlepage}
\begin{center}
\begin{tabular}[c]{c c}
%\includegraphics[bb=0 0 194 352, scale=0.25]{logo} &
\includegraphics[scale=0.25]{img/logo_vect.png} &
\begin{tabular}[b]{l}
\Huge
\textsf{UNIVERSIDAD} \\
\Huge
\textsf{REY JUAN CARLOS} \\
\end{tabular}
\\
\end{tabular}

\vspace{3cm}

\Large
Grado en Ingeniería en Tecnologías de la Telecomunicación  

\vspace{0.4cm}

\large
Curso Académico 2018/2019

\vspace{0.8cm}

Trabajo Fin de Grado

\vspace{2.5cm}

\LARGE
TALLERES DIDÁCTICOS ORIENTADOS A LA DIFUSIÓN DE EXPERIENCIAS VR ENTRE ALUMNOS DE ENSEÑANZAS MEDIAS.

\vspace{4cm}

\large
Autor : Jonatan Santana Pero \\
Tutor : Pedro de las Heras Quirós
\end{center}
\end{titlepage}

\newpage
\mbox{}
\thispagestyle{empty} % para que no se numere esta pagina


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Para firmar
\clearpage
\pagenumbering{gobble}
\chapter*{}

\vspace{-4cm}
\begin{center}
\LARGE
\textbf{Trabajo Fin de Grado/Máster}

\vspace{1cm}
\large
Título del Trabajo con Letras Capitales para Sustantivos y Adjetivos

\vspace{1cm}
\large
\textbf{Autor :} Jonatan Santana Pero \\
\textbf{Tutor :} Pedro de las Heras Quirós 

\end{center}

\vspace{1cm}
La defensa del presente Proyecto Fin de Carrera se realizó el día \qquad$\;\,$ de \qquad\qquad\qquad\qquad \newline de 20XX, siendo calificada por el siguiente tribunal:


\vspace{0.5cm}
\textbf{Presidente:}

\vspace{1.2cm}
\textbf{Secretario:}

\vspace{1.2cm}
\textbf{Vocal:}


\vspace{1.2cm}
y habiendo obtenido la siguiente calificación:

\vspace{1cm}
\textbf{Calificación:}


\vspace{1cm}
\begin{flushright}
Fuenlabrada, a \qquad$\;\,$ de \qquad\qquad\qquad\qquad de 2019
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Dedicatoria

\chapter*{}
%\pagenumbering{Roman} % para comenzar la numeracion de paginas en numeros romanos
\begin{flushright}
\textit{Dedicado a \\
mi mismo} \\
\end{flushright}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Agradecimientos

\chapter*{Agradecimientos}
%\addcontentsline{toc}{chapter}{Agradecimientos} % si queremos que aparezca en el índice
\markboth{AGRADECIMIENTOS}{AGRADECIMIENTOS} % encabezado 



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%% Resumen

\chapter*{Resumen}
%\addcontentsline{toc}{chapter}{Resumen} % si queremos que aparezca en el índice
\markboth{RESUMEN}{RESUMEN} % encabezado

La finalidad de este proyecto es la introducción de diferentes tecnologías a alumnos de enseñanzas medias interesados en la realidad virtual.

La tres tecnologías que suponen el núcleo de este proyecto son:
\begin{itemize}
\item BeetleBlocks.
\item A-Frame.
\item Micro Bit.
\end{itemize}
Para hacerlo, este proyecto esta basado en la ejecución de 3 talleres enfocados en cada una de ellas. Los talleres a su vez forman un todo, con el que conseguiremos una experiencia VR completa en la que primeramente se creará un objeto 3D con programación mediante bloques, a continuación se mostrará como crear un entorno de realidad virtual con A-Frame y por último se explicará como usar el Micro Bit como interfaz de usuario de la experiencia anteriormente creada.

Para realizar el proyecto, primeramente se procedió a un estudio de cada una de las tecnologías y con la ayuda del tutor se acordó en que la mejor forma de introducirlas es con una serie de talleres didácticos con cada uno de ellos incidiendo en una de ellas.

Para la realización de los talleres se ha escogido un formato en el que los alumnos tengan un camino guiado, pero en los que se deja lugar a la creatividad en determinados puntos esto se ha conseguido mediante fichas.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% ÍNDICES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Las buenas noticias es que los índices se generan automáticamente.
% Lo único que tienes que hacer es elegir cuáles quieren que se generen,
% y comentar/descomentar esa instrucción de LaTeX.

%%%% Índice de contenidos
\tableofcontents 
%%%% Índice de figuras
\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de figuras} % para que aparezca en el indice de contenidos
\listoffigures % indice de figuras
%%%% Índice de tablas
%\cleardoublepage
%\addcontentsline{toc}{chapter}{Lista de tablas} % para que aparezca en el indice de contenidos
%\listoftables % indice de tablas

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INDICE%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\chapter{Introducción}
\pagenumbering{arabic} % para empezar la numeración de página con números

\section{Experiencias VR}
\label{sec:In_VR}

La realidad virtual,es la sensación de estar inmerso en un entorno con objetos o escenas de apariencia real. El usuario puede sumergirse en imágenes 3D realistas, generadas por ordenador, a través de tecnología, como los visores de realidad virtual, es una experiencia que luego puede enriquecerse con otros dispositivos.

En los últimos años se ha visto un crecimiento en su importancia y uso, se trata de una tecnología relativamente temprana tanto en su concepción como en su aplicación, hasta los años 90 no se consiguió simplificar los grandes simuladores de realidad virtual en dispositivos portátiles.
Estos van desde cascos de realidad virtual, a gafas de plástico o cartón en los que los smartphones se encargan de hacer realidad la experiencia.

Entre los años 2015 y 2016 se vivió el gran avance en estos dispositivos grandes marcas como HTC o Sony se animaron a sacar estos dispositivos a la venta para el público.

A la hora de hablar de la realidad virtual en este trabajo de fin de grado se ha profundizado en las denominadas experiencias, se trata de entornos de realidad virtual que nos permiten situarnos en medio de la escena, de la que podemos ser espectadores o interactuar dentro de ellas, ayudándonos de sensores o controladores. 

Si bien es cierto que actualmente el mayor uso de la realidad virtual va dirigido a videojuegos, también es empleada en campos como el de la medicina o la educación, punto en el que se centra este trabajo y que se describe en la siguiente sección.

\clearpage


\subsection{Utilidad VR en la educación }
\label{subsec:In_VR1}


El uso de la realidad virtual en la educación, es algo que está empezando a introducirse en la sociedad.
Durante años ha estado limitada a la formación de pilotos aéreos en carísimos simuladores pero gracias a la mejora en la tecnología y la reducción  en costes, podemos ir viendo como poco a poco más universidades e institutos introducen la realidad virtual como apoyo para la enseñanza.

Una gran baza de esta tecnología es su accesibilidad, los visores de realidad virtual ofrecen la mejor experiencia pero con unas gafas de cartón como las Cardboard de Google y un móvil podemos ser capaces de experimentar miles de experiencias en realidad virtual.
Tampoco podemos obviar su inmersión, lo  que aumenta la motivación y aporta un mayor impacto en los procesos de aprendizaje haciendo al alumno partícipe activo de la experiencia y por tanto aumentando su capacidad de retención de lo enseñado. 

Declaraciones como las de Baptiste Grève, creador de la plataformade experiencias virtuales \textit{Unimersiv}\footnote{https://unimersiv.com/}, no hace mas que fundamentar lo positivo de esta tecnología, dado que el cerebro humano retiene el 10\% de lo que lee, el 20\% de lo que oye y el 90\% de lo que experimenta. 

\section{Diseño de figuras 3D}
\label{sec:In_3D}

El diseño de las figuras en 3D se realiza mediante software de diseño, existen multiples herramientas de creación y diseño 3D tanto de pago como gratuitas.Este trabajo de fin grado se va a dar uso a dos de ellas.

Principalmente BeetleBlocks\footnote{http://Beetleblocks.com/} una plataforma Open Source que nos propone un método de diseño mas sencillo y basado en la programación por bloques lo cual resulta perfecto para introducirse en el diseño 3D como se puede leer en el artículo \cite{Prog:_bloques}, será uno de los núcleos de este trabajo y la que es usada para llevar a cabo el diseño de las figuras en este trabajo.
La segunda Blender \footnote{https://www.blender.org/} un software Open Source de creación 3D más clásico y cuyo uso se limitará a pequeños retoques a las figuras creadas previamente con BeetleBlocks.
\clearpage
Más adelante en este trabajo se describe la manera de crear objetos con BeetleBlocks en el capítulo \ref{sec:3D_Design}, estos irán desde figuras geométricas básicas, a formas tan complejas como uno quiera debido a la versatilidad de la plataforma.

Como este trabajo de fin grado esta focalizado en la creación de talleres didácticos para gente sin experiencia en el diseño 3D, BeetleBlocks nos permite mostrar el diseño 3D de una forma amena y menos compleja que si usáramos una herramienta más potente, esta afirmación queda fundamentada en este par de artículos ~\cite{BeetleBlocks:_info} ~\cite{BeetleBlocks:_info2}.

\subsection{Entornos VR con figuras en 3D}
\label{subsec:In_3D1}

Los entornos de realidad virtual se componen de figuras en 3 dimensiones. Es el propio entorno en si el que hace que la experiencia se denomine de realidad virtual.
Al igual que para para el diseño 3D existen multiples programas de software que nos permiten la creación de estos entornos.

Tal y como está planteado este trabajo, no hemos buscado una experiencia realista sino una centrada en el aprendizaje de una experiencia básica que nos permita familiarizarnos con su creación.
Debido a esto en este trabajo de fin de grado hemos optado por A-Frame una utilidad de creación de experiencias y entornos VR Open Source y gratuito.

Gracias a ella se puede aprender a crear un entorno de realidad virtual básico en el que se pueden exportar todo tipo de figuras. La creación del entorno de realidad virtual con A-Frame se llevará a cabo en el capítulo~\ref{sec:Aframe}

\section{Micro Bit}
\label{sec:In_Microbit}
``Micro:bit es una pequeña computadora programable, diseñada para hacer que el aprendizaje y la enseñanza sean fáciles y divertidos!"

Esta es la frase que se puede encontrar cuando se entra en su página oficial~\footnote{\textit{https://microbit.org/es}}, y eso es Micro:bit, un sistema de Hardware embebido, diseñado por la BBC para la enseñanza informática en el Reino Unido.
\clearpage
Su primera aparición fue el 12 de Marzo de 2015, y se empezó a distribuir en Febrero de 2016, consta de un procesador ARM CortexM0, acelerómetro y magnetómetro, conectividad Blueethoot y USB, 25 leds, 2 botones programables y puede ser alimentada por medio de pilas o USB. Las entradas y salidas del dispositivo están formadas por 5 anillos conectores que forman parte de un conector mayor de 23 pines, la mayoria de esto puede verse en la Figura ~\ref{figura:Microbit_In}.

Gracias a la gran cantidad de sensores que incorpora, sólo con la tarjeta se pueden llevar a cabo centenares de proyectos. BBC Micro: bit también es una plataforma IoT (Internet of Things), lo que la hace muy interesante para usuarios avanzados.
Y es Open Source, por supuesto. Tanto el hardware como el software de micro:bit es de código abierto un requisito indispensable ya que como todas las técnologías utilizadas en este trabajo, esto ha ayudado a que todo el que realice los talleres pueda continuar experimentando en su propio ordenador una vez han sido finalizados. 

\begin{figure}[H]
\includegraphics[width=0.8\textwidth]{img/microbit}
\caption{BBC Micro:bit}
\label{figura:Microbit_In}
\end{figure}

\subsection{Micro Bit como interfaz de usuario}
\label{subsec:In_Microbit_I}

Como ya hemos visto Micro Bit posee múltiples aplicaciones.
Su función en este trabajo de fin grado va dirigida a la interfaz de usuario, es decir, será el controlador de la experiencia de realidad virtual que previamente es creada mediante A-Frame.

A la hora de buscar una funcionalidad para el Micro Bit el alumno poseía un ejemplo de movimiento físico en un entorno de A-frame, tras el estudio de las posibilidades que ofrece la programación del Micro Bit se ha conseguido implementar una serie de funciones extras.
Al finalizar el último de los talleres El Micro Bit permitirá un movimiento dentro de la experiencia tanto físico como de la cámara mediante el acelerómetro integrado, también se añade un método de interacción con el objeto creado con BeetleBlocks y animado con A-Frame.

Para hacer esto se ha realizado un programa en micropython una variación de Python adaptada al Micro Bit que nos permite ejecutar programas de python en nuestro dispositivo mediante a la importación de una serie de módulos de Python todo esto se describe en el la sección~\ref{subsec:Microbit_prog}, pero esto es solo un ejemplo de la versatilidad del Micro Bit.

Como forma de apoyo en el aprendizaje de micropython y diversas funciones y metodología de Python se ha hecho uso de las siguientes documentaciones~\cite{MicroPython:_doc}~\cite{Python:_doc}.

\section{Estructura de la memoria}
\label{sec:In_Estruc}

Tras esta introducción en la que se ha visto una visión de la realidad virtual origen y evolución, así como la descripción y significado de las experiencias VR y su continua introducción en la educación como método didáctico y de gran valor práctico.
Seguidamente se describen las herramientas de diseño 3D  BeetleBlocks y Blender y se describe el diseño de objetos en 3D mediante bloques ya que es el método que se usará en este trabajo de fin de grado y el cual resulta perfecto para introducirse en la creación y diseño de estas figuras.
La última tecnología a describir es el Micro Bit y dentro de sus múltiples posibilidades, se explica el porqué introducirlo en una experiencia de A-Frame y es para darle un uso como interfaz de usuario con esto se consigue complementar la experiencia de realidad virtual.\\


En el siguiente capítulo se describen los objetivos que se presentan en este trabajo de fin de  grado, en el Capítulo~\ref{chap:Obj}, en el que también hablamos de la motivación que que se ha tenido para la elección de este proyecto, como de la metodología y el plan de trabajo que se ha seguido.\\


A continuación en el Capítulo~\ref{chap:Cr_VR} se ofrece una explicación del proceso de estudio de las diferentes tecnologías que se han usado en este trabajo así como un breve explicación de uso o práctica de cada una de ellas para ayudar a comprender su funcionamiento.
Se puede dividir por tanto en tres partes diferenciadas.
\begin{itemize}
\item Sección~\ref{sec:3D_Design}.

Su contenido corresponde al diseño de objetos en 3D con la descripción de las dos tecnologías usadas  BeetleBlocks y Blender.
\item Sección~\ref{sec:Aframe}.

Centrada en A-Frame en esta sección se describeel método y creación de experiencias de realidad virtual usando este \textit{framework}.
\item Sección~\ref{sec:Microbit}.

Se describen los distintos métodos de programación del Micro:bit y se definen los módulos que se usan para implementar la función de controlador. 
\end{itemize} 

En el capítulo~\ref{chap:talleres} se encuentra la serie de 3 talleres o prácticas de las que consta el núcleo práctico de este trabajo.

El contenido y tecnología implementada de cada uno puede verse en la Tabla ~\ref{tabla:ejemplo} y es el siguiente 
\begin{itemize}
\item Primer taller, sección~\ref{sec:Taller1}, el objetivo de este taller es la creación de una figura 3D mediante BeetleBlocks y su método de programación mediante bloques.
\item Segundo taller, sección~\ref{sec:Taller2},la pretensión de este taller es conseguir impartir el método de creación de una experiencia de realidad virtual haciendo uso de las herramientas que ofrece A-frame.
\item Por último un tercer taller, sección~\ref{sec:Taller3},centrado en el proceso de programación del Micro Bit para implementarlo en A-Frame como controlador y así poder moverse con él.
\end{itemize} 


\begin{table}[H]
 \begin{center}
  \begin{tabular}{ | c | c | c | c |} % tenemos tres colummnas, la primera alineada a la izquierda (l), la segunda al centro (c) y la tercera a la derecha (r). El | indica que entre las columnas habrá una línea separadora.
    \hline
     & TALLER 1 & TALLER 2 &TALLER 3\\ \hline % el hline nos da una línea vertical
    Tecnología & BeetleBlocks & A-Frame & Microbit \\ \hline
    Contenido & Diseño de un objeto 3D & Creación de experiencia VR & Programar Micro:bit como IU \\
    \hline
  \end{tabular}
  \label{tabla:ejemplo}
  \caption{Talleres didácticos}
 \end{center}
\end{table}

El capítulo~\ref{chap:conclusiones} corresponde a las conclusiones, es donde se analizan los resultados obtenidos y si por tanto se ha alcanzado a conseguir los objetivos propuestos previamente.\\
Además se expone la aplicación de los conocimientos obtenidos por el alumno durante la realización de este grado que han sido fundamentales para la consecución de este trabajo de fin grado.
Los dos últimos puntos corresponden a los conocimientos útiles aprendidos propios de este trabajo y a las posibles mejoras y trabajos futuros relacionados con los expuestos aquí que se podrían realizar o aplicar en un futuro.\\


Las últimas secciones de este trabajo corresponden a la Bibliografía y los Apéndice~\ref{chap:apen} y Apéndice~\ref{chap:apen2} en el que se describe de una forma más detallada  una guia de uso y descripción de todos los bloques de BeetleBlocks y el proceso de creación de un objeto en 3D con BeetleBlocks.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Objetivos%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\chapter{Objetivos}
\label{chap:Obj}

\section{Objetivos}
\label{sec:objetivos}

Una vez han sido descritas las experiencias de realidad virtual, el diseño 3D así como las tecnologías que van a ser usadas en este trabajo, el siguiente paso es describir la serie de objetivos que se proponen conseguir con este trabajo de fin de grado.

\subsection{Exponer la utilidad de la VR en la educación}
\label{subsec:Obj1}

El primer objetivo a la hora de realizar este trabajo de fin de grado, es exponer la utilidad de la realidad virtual en la educación, y como gracias a ella podemos llegar a aprender y experimentar con un entorno de realidad virtual de una forma práctica.

Gracias a la novedad y el gran valor interactivo que proporciona la realidad virtual la retención de las tecnologías aplicadas por los alumnos son retenidas de una manera efectiva.  

\subsection{Creación de un objeto 3D y una experiencia VR}
\label{subsec:Obj2}

El segundo objetivo a conseguir es lograr crear una dirección didáctica en la que los alumnos de enseñanzas medias sean introducidos ala creación de objetos 3D y de una experiencia de realidad virtual.

Para conseguirlo se ha optado por la programación mediante bloques para el diseño 3D en base a este artículo~\cite{Prog:_bloques} que corrobora su efectividad como método introductorio a la hora de realizar un primer acercamiento a este campo.


\subsection{Implementar el Micro:bit dentro de A-Frame}
\label{subsec:OBj3}

El tercer y último objetivo esta relacionado con el Micro:bit.
La introducción de este dispositivo se introduce en este trabajo gracias a la recomendación del tutor.

A la hora de implementar alguna función del Micro:bit que estuviera relacionada con los dos talleres previos, se concluyó que la mejor opción es darle funciones de controlador o interfaz de usuario en la experiencia de A-Frame.

El objetivo por tanto es integrarlo en A-Frame programándolo con su lenguaje propio micropython.Esto llevará a cabo una investigación previa del alumno de este lenguaje y sus diferentes módulos.

\section{Motivación}
\label{sec:Motiv}

La principal motivación para llevar a cabo a la realización de este trabajo de fin de grado, es la propia tecnología en sí, el alunmo siempre se ha visto interesado en las temáticas tratadas, tanto el diseño de objetos en 3D, como las experiencias en realidad virtual y la programación embebida.

El gran potencial que tienen, y los múltiples usos que se le pueden dar han sido muy interesantes desde un primer momento, para el alunmo ha sido una gran motivacíon la  realización de este trabajo ya que podía aprender acerca de estos ámbitos, que resultaban una novedad en sus conocimientos y además darle una utilidad en forma de talleres para que más gente pueda aprovechar la investigación llevada a cabo.

Otra motivación principal esta relacionada con los entornos de desarrollo de las 3 tecnologías principales, BeetleBlocks, A-Frame y Micro:bit incitan a la creatividad debido a su potencial y múltiples funciones con una interfaz sencilla.
\clearpage
\section{Metodología y Plan de Trabajo}
\label{sec:MyP}  
 En esta sección se expone la metodología y el plan de trabajo que se han llevado a cabo para la realización de este  trabajo de fin de grado tanto para la memoria como para la serie de talleres.

\subsection{Metodología}
\label{subsec:Metod}

La metodología que se ha seguido para la realización de este trabajo de fin grado, esta orientada en la construcción de una serie de talleres didácticos.

Un taller es un programa educacional corto e intensivo, para una cantidad relativamente pequeña de personas, en un área de conocimientos determinada que hace énfasis en la participación para la resolución de problemas. 

Antes de la creación de los talleres ha sido necesario un estudio de las tecnologías utilizadas, realización de pequeños tutoriales y selección de las prácticas más adecuadas para el nivel de conocimientos de los participantes.

Los pasos que se han seguido para la creación de los talleres son los siguientes:
\begin{itemize}
\item Definir los objetivos del taller.
\item Adecuarlos a los participantes, en este caso se trata de alumnos de enseñanzas medias por lo que deben ser acordes a sus conocimientos.
\item Definir el formato del taller, será un taller en el que los alumnos harán experiencias guiadas pero en las que participaran activamente en ciertos momentos para involucrarlos con el taller.
\end{itemize}

Cada taller a su vez sigue una metodología común que viene dada por los siguientes puntos:
\begin{enumerate}
\item[$*$] Presentación del tema general del taller.
\item[$*$] Planteamiento de los objetivos del taller.
\item[$*$] Presentación del software que se usará.
\item[$*$] Fomentar la participación activa
\item[$*$] Una vez finalizado resumir la sesión y pedir feedback al grupo.
\end{enumerate}
\subsection{Plan de trabajo}
\label{subsec:Plan} 

En base a la realización de los talleres se debía tener un conocimiento profundo de todo el software que se usa en ellos,debido a esto se ha realizado un plan de trabajo en el que primeramente se estudiaron las 2 tecnologías BeetleBlocks y A-Frame.

Gracias a la ayuda del tutor mediante tutorias a través de Hanghouts y mediante la investigación y realización de tutoriales se obtuvo una base sólida acerca de ellas.\\

Posteriormente se contempló el uso de Tensorflow para añadir un tipo de interfaz de usuario a la experiencia de realidad virtual pero este primer planteamiento fue desechado en detrimento de la introducción del Micro: bit, la popularidad y variedad de aplicaciones de este último fue determinante, se llegó a la conclusión de introducirlo como interfaz de usuario por tanto se desarrolló un programa en python que le otorgara funciones de controlador dentro de las experiencias de A-Frame.\\

Una vez cimentado un conocimiento acerca de BeetleBlocks, A-Frame y Micro:bit se pasó a plantear los talleres y se dividieron en una serie de 3 talleres autoconclusivos pero a su vez recursivos entre ellos.
Con esto se consigue que realizando uno de ellos se obtuvieran conocimientos acerca de la tecnología en cuestión y a su vez alguien que realizara los tres tenga una experiencia completa de realidad virtual.
El formato de los talleres es del tipo Scratch.

[...]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Creación de experiencias VRs%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\chapter{Creación de experiencias VR}
\label{chap:Cr_VR}

\section{Tecnologías}
\label{sec:Tecno}
Este capítulo se centra en presentar y desarrollar el software y el hardware que va a ser usado en este trabajo, además se ofrece su forma de uso y varios ejemplos para facilitar su comprensión.
\section{Diseño 3D}
\label{sec:3D_Design}
Dentro del diseño 3D, se ha decidido dividir tres partes diferenciadas correspondientes a los diferentes puntos en los que se divide esta sección.

En primer lugar en el punto \ref{subsec:Prog} se trata la programación mediante bloques, se explica la razón por la que es un método válido a la hora de ofrecer un taller didáctico centrado en introducir el diseño 3D.

BeetleBlocks es una herramienta que usa la programación mediante bloques para el diseño de objetos 3D, tanto el análisis como el uso de esta herramienta es tratado en \ref{subsec:Beetle} y supone el núcleo del diseño 3D realizado por el alumno en este trabajo.

Por último en la subsección \ref{subsec:Blender} se expone Blender, la segunda de las herramientas de diseño 3D tratadas en este trabajo, su uso en este caso se limita a proporcionar el formato buscado para el objeto creado con BeetleBlocks, aunque cabe recalcar que se trata de un software de diseño mucho más complejo que este último.

\subsection{Programación mediante bloques}
\label{subsec:Prog}

La programación mediante bloques, facilita mucho las cosas si no no se tiene experiencia de ningún tipo con la programación, en este trabajo de fin de grado aparece tanto en BeetleBlocks como en uno de los métodos de programación del Micro: bit.
 
Artículos como los siguientes \cite{Prog:_bloques} \cite{Prog:_bloques2}, evidencian que el surgimiento de este tipo de programación esta empezando a introducirse en el comienzo de la dodencia de la programación y los resultados obtenidos son mejores en todos los conceptos de la programación, como se puede observar en la siguientes Figuras \ref{figura:Prog_bloques_Compare} y \ref{figura:Prog_bloques_Compare2}.

\begin{figure}[H]
    		\centering
    		\includegraphics[width=15cm, keepaspectratio]{img/prog_bloques}
		\caption{Puntuacion media de la evaluación de estudiantes a preguntas de programación}
		\label{figura:Prog_bloques_Compare}
\end{figure} 

\begin{figure}[H]
    		\centering
    		\includegraphics[width=12cm, keepaspectratio]{img/prog_bloques2}
		\caption{Tasa de rendimiento medio para estudiantes en diferentes conceptos}
		\label{figura:Prog_bloques_Compare2}
\end{figure} 

\subsection{BeetleBlocks} 
\label{subsec:Beetle}
\begin{wrapfigure}{r}{0.35\linewidth}
    \centering
  \includegraphics[width=0.4\textwidth]{img/Beetlelogo}\\
\end{wrapfigure}
Beetle Blocks es un entorno de programación visual por bloques que permite diseñar formas tridimensionales este proyecto es creado por Eric Rosenbaum, Duks Koschitz, y Bernat Romagosa, además de la ayuda en la programación de Jens Mönig.
De acuerdo con lo que expone Bernat Romagosa, desarrollador principal de este software, en el artículo \cite{BeetleBlocks:_Bernat}, Beetle Blocks es más que una herramienta: es también una puerta de entrada muy atractiva al mundo de la programación.
El editor de BeetleBlocks está basado en  Scratch e implementado usando Snap! y ThreeJS.

Para empezar a usar la herramienta basta con acceder a la web \footnote{http://beetleblocks.com/} y hacer click sobre \textit{``Run BeetleBlocks"}.
La pantalla mostrada al arrancar Beetleblocks corresponde a la Figura~\ref{figura:Inicio Beetle Blocks}, se pueden 3 áreas diferenciadas a la izquierda el área de los bloques en el que se muestran los bloques correspondientes a la categoría seleccionada, en el centro el área de trabajo para colocar los sprites o conjuntos de bloques, y a la derecha el área de visualización 3D , para observar el resultado de computación de los bloques creados.
\begin{figure}[H]
    		\centering
    		\includegraphics[width=15cm, keepaspectratio]{img_b/Bettleblocks}
		\caption{Inicio Beetle Blocks}
		\label{figura:Inicio Beetle Blocks}
\end{figure} 

Es recomendable crear una cuenta en BeetleBlocks antes de empezar a usarlo para este trabajo la cuenta que se ha usado ha sido con el usuario \textbf{jonybob}  y Contraseña \textbf{TFG2490}.
\clearpage
\subsection{Categorías de los bloques} 
\label{subsec:Beetle}
Como ya se expone anteriormente en el trabajo Beetle Blocks utiliza la promación mediante bloques para crear los objetos en 3D, estos tienen diferentes tipos de categorías según su función, el fundamento de Beetleblocks es programar un escarabajo virtual (Figura~\ref{figura:Beetle} para que, con su movimiento, vaya generando formas tridimensionales.
Las diferentes categorías de los bloques y su función es la siguiente:
  \begin{enumerate}
  	\item Motion: Donde se engloban los bloques para movernos por la malla
  	\item Shapes: Figuras y formas predeterminadas.
  	\item Sensing: funciones para usar con los bloques. 
  	\item Variables: creación y uso de variables de entorno. 
  	\item Control: operadores para los conjuntos de bloques, eventos , funciones etc..
  	\item Colors: Bloques para dar color a las figuras.
  	\item Operators: operadores matemáticos para usar en los bloques.
  	\item Myblocks: bloques propios creados en el proyecto.
  	
  \end{enumerate}
\begin{figure}[H]
    		\centering
    		\includegraphics[width=8cm, keepaspectratio]{img_b/beetle}
		\caption{Escarabajo del área de visualización 3D}
		\label{figura:Beetle}
\end{figure} 

En el Apéndice~\ref{chap:apen} se puede ver en más profundidad la descripción y uso de todos los bloques.

\subsection{Prácticas de aprendizaje en BeetleBlocks} 
\label{subsec:Beetle}
A la hora de aprender el uso de Beetle Blocks el alumno comenzó diseñando figuras básicas para familiarizarse con el uso de los distintos bloques.
A continuación se exponen una serie de ejemplos prácticos que se utilizaron para el aprendizaje del uso de la herramienta, se muestra como crear figuras básicas, moverse en los 3 ejes espaciales (x, y, z ) y el uso de diferentes funciones. y por último un objeto que usa todo lo aprendido para la creación de unos auriculares.


\begin{itemize}

	
	\item \large Movimiento por los ejes \\
	\normalsize
	Dependiendo de como sea la orientación de las figuras dibujadas es necesario moverse por los ejes y orientar el escarabajo que como ya se sabe sirve como puntero de orientación para dibujar. El bloque que se usa para moverse y situarse en donde se quiere se puede observar en la siguiente Figura~\ref{figura:Beetle_move}
	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.22\textwidth]{img_b/axis}
		\caption{Bloque para moverse en los ejes}
		\label{figura:Beetle_move}
	\end{figure}

	\item \large Círculos \\
	\normalsize
	Para crear círculos de una manera muy sencilla simplemente basta con  empezar a dibujar curvas o líneas, con los bloques correspondientes y moverse hasta completar los 360 grados del circulo girando \textit{x} número de grados uno de los ejes.
	En el ejemplo de la Figura \ref{figura:Beetle_circle} se dibujaría un círculo rojo moviéndose 0.25 		hacia delante cada ver que se gira 18 grados, esto se hace 20	veces para completar los 360 grados (18º * 20 = 360º).
	
	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.22\textwidth]{img_b/Circulos}
		\caption{Bloque para crear círculos}
		\label{figura:Beetle_circle}
	\end{figure} 
\clearpage	
	\item \large Figuras predeterminadas \\
	\normalsize
	Las figuras predeterminadas que nos ofrece Bettleblocks son el cubo (en dos formas), el cilindro y la esfera cuyos bloques se corresponden con los de la Figura~\ref{figura:Beetle_figures} en orden respectivo de arriba hacia abajo. Estas figuras permiten hacer varias figuras más complejas combinándolas entre ellas.
	
	
	\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.28\textwidth]{img_b/figuras_4}
		\caption{Bloques de las figuras predeterminadas de BeetleBlocks}
		\label{figura:Beetle_figures}
	\end{figure} 	
		
	\item \large Auriculares \\
	\normalsize	
	Como parte final en el aprendizaje de Beetleblocks, se ha creado una figura más compleja para corroborar lo aprendido.La figura en cuestión son unos auriculares, su proceso de creación al detalle se expone en el Apéndice~\ref{chap:apen2}, y el objeto y bloques que lo componen se puede ver en la Figura~\ref{figura:Beetle_headphones}
	
\begin{figure}[H]
 \centering
  \subfloat[Bloques]{
   \label{f:Colores}
  \includegraphics[width=0.6\textwidth, height=0.5\textwidth]{img_b/headphones_blocks}}
    \subfloat[Imagen del objeto]{
   \label{f:Funciones}
    
     \includegraphics[width=0.4\textwidth, height=0.5\textwidth]{img_b/cascos_pic}}
   \caption{Bloques e imagen de auriculares}
 \label{figura:Beetle_headphones}
\end{figure}
\end{itemize}

\clearpage
\subsection{Blender}
\label{subsec:Blender}

Blender es una potente herramienta open source de creación 3D.
En este trabajo de fin de grado se le ha dado un uso muy concreto, se trata de convertir la figura creada con BeetleBlocks a un formato compatible con A-Frame ( \textbf{\textit{.obj}} y \textbf{\textit{.mtl}} ). Como es \textit{Open Source} su documentación~\cite{Blender:_doc} es accesible para todo aquel que la desee y es la que se ha utilizado para este trabajo de fin de grado.
La pantalla mostrada al iniciar Blender se puede ver en la Figura \ref{figura:Init_BlenderA}

\begin{figure}[H]
    		\centering
    		\includegraphics[width=14cm, keepaspectratio]{img/blender_0}
		\caption{Blender}
		\label{figura:Init_BlenderA}
 	\end{figure} 

Estos son los pasos necesarios para exportar la figura en el formato correcto: \begin{wrapfigure}{r}{0.35\linewidth}
    \centering
  \includegraphics[width=0.25\textwidth, height=0.4\textwidth]{img_b/export_blender}
  \caption{Exportar objeto}
		\label{figura:Check}
\end{wrapfigure}

\begin{enumerate}

	 \item Borrar el cubo, posicionando el ratón encima y presionando    	\textbf{\textit{x}} para borrarlo.  
	 
	 \item Se pulsa \textit{espacio} y se introduce en el cuadro de texto \textbf{\textit{import stl}}, se importa la figura de Beetle Blocks previamente creada y exportada con un formato \textit{stl}.
	 
	 \item Se pulsa \textit{espacio} de nuevo y se introduce \textbf{\textit{export obj}} en el cuadro de texto, como se ve en la Figura~\ref{figura:Check} se deben marcar las \textit{Checkboxes} 						\textbf{\textit{Write Normals, Write Materials}}.

\end{enumerate}

\clearpage

\section{A-frame}
\label{sec:Aframe}

A-Frame es un framework que permite crear experiencias de realidad virtual.Originalmente fue concebido dentro de Mozilla Firefox, y ahora es administrado por desarrolladores de Supermedium (Diego Marcos, Kevin Ngo) y Google (Don McCurdy). A-Frame fue diseñado para ofrecer una manera potente de desarrollar contenido VR. Al ser una plataforma independiente Open Source, A-Frame ha crecido hasta convertirse en una de las comunidades de realidad virtual más grandes.

Se integra en un documento HTML haciendolo simple de usar en primera instancia, aunque el núcleo es un potente framework ECS\footnote{Entity Component System} para Three.js donde los desarrolladores  de software pueden crear escenas WebVR y 3D usando HTML.

Por tanto se compone de elementos propios basados en HTML y de la importación de archivos en Javascript para complementar  y añadir funcionalidades, todo esto se puede ver de una forma más detallada en su documentación~\cite{A-Frame:_doc}.

A-Frame  da soporte a la mayoría de dispositivos de realidad virtual como Vive, Rift, Windows Mixed Reality, Daydream, GearVR, Cardboard, Oculus Go, e incluso puede ser usada para realidad aumentada. El objetivo de A-Frame es definir una experiencia inmersiva completa yendo más allá del contenido en 360º, y dando soporte completo para controladores y seguimiento posicional.

\subsection{ A-frame dentro de HTML}
\label{subsec:HTML}
A-Frame se integra dentro del documento HTML, para usarlo es necesario importarlo en la cabecera del documento:
\begin{verbatim}
<head>
 <script src="https://aframe.io/releases/0.8.0/aframe.min.js">
 	</script>
 [...]    		
</head>		
\end{verbatim}

\clearpage
De entre los  principales conceptos y elementos que introduce A-Frame se van a destacar cuatro de ello las escenas~ \footnote{https://aframe.io/docs/0.9.0/core/scene.html}, las entidades~\footnote{https://aframe.io/docs/0.9.0/core/entity.html} y los componentes~\footnote{https://aframe.io/docs/0.9.0/core/component.html} y los primitivos~\footnote{https://aframe.io/docs/0.9.0/introduction/html-and-primitives.html}.

\begin{itemize}

	\item \textit{Escene}: es el núcleo de A-Frame,  el lugar donde se desarrolla todo, todas las entidades son creadas dentro de la escena, por lo tánto sería el `` escenario" vacío de la experiencia 3D creada. Para crear una escena dentro del documento HTML hay que añadirla en el $<$body$>$ del documento.
\begin{verbatim}
<html>
  <head> [...]
      </head>
  <body>
    <a-scene>
      </a-scene>
  </body>
</html>
\end{verbatim}
	
	\item \textit{Entity}: como se especifica en el patrón ECS(Sistema-entidad-componente), las entidades son objetos a los que se le añaden componentes, por defecto las entidades tienen las componentes de posición rotación y escala, para explicarlo de una forma más sencillas las entidades representan los objetos 3D en la escena.En A-Frame las entidades se representan mediante el elemento $<$entity $>$.A continuación se muestra como añadir un objeto de tipo box, con color rojo, a la escena:
\begin{verbatim}
<body>
 <a-scene>
  <a-entity geometry="primitive: box" material="color: red">
    </a-entity>
 </a-scene>
</body>

\end{verbatim}

	\item \textit{Component}: Como se define en el patrón ECS, una componente es una porción modular de datos que se añade a una entidad para otorgarla una apariencia, comportamiento y funcionalidad determinada. Las componentes pueden ser de dos formatos, con una propiedad única o con varias.A continuación se muestra un ejemplo de ambas.
\begin{verbatim}
<body>
 <a-scene>	
  <a-entity position="1 2 3"></a-entity>
  <a-entity light="type: point; color: crimson"></a-entity>
 </a-scene>
</body> 
\end{verbatim}
	\item \textit{Primitives}: A-Frame proporciona una gran cantidad de objetos predeterminados como $<$a-box $>$ $<$a-sky $>$ , los cuales son identificados como primitives o también nombrados primitivos en este trabajo, proporcionan una manera sencilla de usar figuras 3D para empezar a usar A-Frame,y admiten la adición de componentes . Los desarrollados además pueden crear sus propios primitivos. Unos ejemplos de los primitivos precargados son:
\setlength{\columnsep}{0.1in}
 \begin{multicols}{2}
 \begin{itemize}
	\item $<$a-box$>$	
	\item $<$a-camera$>$	
	\item $<$a-circle$>$
	\item $<$a-cursor$>$
	\item $<$a-cylinder$>$
	\item $<$a-image$>$
	\item $<$a-ring$>$
	\item $<$a-plane$>$
		
\end{itemize}
\end{multicols}

\end{itemize} 

\subsection{Uso de JavaScript dentro de A-Frame}
\label{subsec:JS}

Gracias a la importación de archivos en JavaScript se pueden añadir multiples funcionalidades a A-Frame.

Un módulo o paquete muy extendido entre los desarrolladores es el aframe-extras~\cite{A-Frame:_extras} se trata de una serie de Add-ons y helpers para A-Frame, e incluye componentes de control, modelos predefinidos, primitives \dots.

Otro recurso muy utilizado para A-Frame y basado en JavaScript es la importación de components
\footnote{https://aframe.io/docs/0.9.0/introduction/entity-component-system.html.}, como se puede ver anteriormente estos nos habilitan una serie de funciones, existe una amplia biblioteca de components para importar, entre ellos hay algunos que se organizan en paquetes o módulos como superframe.
\footnote{https://github.com/supermedium/superframe.}

El uso de cada component es particular  y puede encontrarse en su documentación~\cite{A-Frame:_doc}, pero generalmente para usar un component hay que vincularlo con una entidad \textit{$<$a-entity$>$} y configurarlo.\\
Tomando como ejemplo particle system, su importación y uso sería de la siguiente forma:

\begin{itemize}
\item Se importa el componente en el index.html de la misma manera que ya se mostró con A-Frame:
\begin{verbatim}
<head>
 <script src="https://aframe.io/[...].min.js">
             </script>
 <script src="https://unpkg.com/aframe-[...]-component.min.js">
             </script>    		
</head>		
\end{verbatim}

\item Y a continuación se vincula particle system con una entidad
\begin{verbatim}
<body>
 <a-scene>
  <a-entity particle-system="preset: snow" position="0 0 -10">
        </a-entity>
 </a-scene>
</body>
\end{verbatim}

\end{itemize}

\clearpage

\section{BBC Micro Bit}
\label{sec:Microbit}

La última tecnología en introducir en este trabajo de fin de grado es el Micro Bit, ya se expone en el capítulo~\ref{sec:In_Microbit} su definición y características, su función y objetivo en este trabajo es programar las funcionalidades necesarias para que se convierta en el controlador del escenario de A-Frame previamente creado.

Dentro del proceso de implementación de esta funcionalidad en el MicroBit cabe destacar dos herramientas fundamentales \textit{pyautogui} y \textit{bitio}, son unos módulos de micropython que aportan diversas funcionalidades.

Para el inicio del desarrollo y estudio de esta funcionalidad se tuvo la ayuda de esta práctica \footnote{github.com/sarehp/microbit-aframe}, que se encuentra en el repositorio de GuitHub del tutor. En ella se puede observar el uso de estas dos herramientas y fue idónea para servir de punto de partida por parte del alumno.

El siguiente paso fue llevar a cabo una serie de test y pruebas con Bitio y Pyautogui para aprender sus distintas funcionalidades.
En las siguientes secciones \ref{subsec:pyautogui} y ~\ref{subsec:Bitio} se expone más detalladamente documentación y función de estos dos módulos.
\subsection{Pyautogui}
\label{subsec:pyautogui}
Para aprender a utilizar pyautogui se han utilizado estas documentaciones~\cite{PyAutoGUI:_doc}

Como se puede leer en ellas, pyautogui es un módulo de python que nos permite mapear el teclado y el ratón, es decir controlar mediante la programación todas las teclas de ambos dispositivos.

Gracias a pyautogui, se ha podido mapear las pulsaciones de las teclas del teclado o movimientos del ratón a las interacciones con el Micro Bit en forma de gestos y pulsaciones de los botones.

El código fuente se encuentra en el siguiente repositorio de GitHub~\footnote{ https://github.com/asweigart/pyautogui}.

\subsection{Bitio}
\label{subsec:Bitio}

Bitio es la segunda herramienta que se ha usado para conseguir convertir nuestro Micro Bit en un controlador, se trata de una libreria de Micro Bit para Python,  nos permite correr código de python en nuestro PC y poder interactuar directamente con el Micro Bit. 

Para aprender su uso se siguió la documentación~\cite{Bitio:_git} que se encuentra en un repositorio de GitHub creado por David Whale, el encargado de desarrollarlo.

En la sección \textit{Getting Started} se exponen los pasos necesarios para instalarlo en el programa de python, además se explica como hacer la conexión con el Micro Bit y una serie de ejemplos de las funciones propias de bitio como pueden ser leer los valores del acelerómetro o detectar cuando se pulsa uno de los botones.

\subsection{Micropython}
\label{subsec:Microbit_py}

Mycropython es el lenguaje de programación propio del Micro Bit. En este trabajo de fin de grado  todas las acciones se han desarrollado en este lenguaje y a la hora de realizar los programas que corren las acciones de la placa se ha contado con un apoyo en su documentación~\cite{MicroPython:_doc}.
Esta basado en Python~\cite{Python:_doc} se usa de una forma prácticamente idéntica. Cualquier editor de texto es válido para programar los scripts, el recomendado oficialmente es el editor Mu Figura~\ref{figura:Mu}.
Permite de una forma intuitiva cargar el código en el dispositivo con un botón dedicado para ello y ofrece entre sus distintos modos la posibilidad de visualizar la salida estándar.

\begin{figure}[H]
\centering
\includegraphics[width=0.7\textwidth]{img/Mu_editor}
\caption{Editor Mu}
\label{figura:Mu}
\end{figure}

Si no se cuenta con el editor de Mu la forma de cargar los programas en el MicroBit es mediante una terminal, para ello ya sea en Windows como en Linux es necesario tener una compilación de Python instalada en el sistema operativo y lanzar el programa.
\subsection{Programación del Micro:bit mediante bloques(Makecode)}
\label{subsec:Microbit_prog}

Makecode es un editor para programar el Micro:bit que usa el método de programación por bloques~\cite{Prog:_bloques}~\cite{Prog:_bloques2}.

Con una interfaz muy parecida a la de BeetleBlocks divide sus bloques en grupos, que aportan distintas funciones como Bucles , acciones para los LEDs, Lógica, Matemática \dots etc

En la web de Makecode\footnote{https://makecode.microbit.org/} están disponibles numerosos tutoriales para familiarizarse con su uso.
Aunque en este trabajo Makecode no ha sido utilizado para el desarrollo de las funcionalidades, se profundizó en cada uno de los tutoriales ya que ofrecen una mejor visión global de las posibilidades del Micro:bit, pudiendo programarse sencillos juegos de una forma rápida y amena.

En la siguiente figura~\ref{figura:Makecode} se puede ver su aspecto inicial al arrancarlo, posee una distribución común de la programación por bloques con los diferentes grupos de funciones y variables a la izquierda \textbf{(2)} y una área de trabajo grande para arrastras los bloques y crear los \textit{sprites} \textbf{(3)}.
Como complemento se puede hacer una previsualización del resultado de la ejecución de los bloques creados\textbf{(1)}.

\begin{figure}[H]
\includegraphics[width=1\textwidth]{img/Makecode}
\caption{Makecode}
\label{figura:Makecode}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Diseño e implementación de los talleres %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\chapter{Diseño y desarrollo de los talleres}
\label{chap:talleres}

\section{Introducción y propósito de los talleres}
\label{sec:In_Taller}

El principal objetivo de este trabajo de fin de grado es introducir todas estas herramientas que hemos explicado previamente a alumnos de enseñanzas medias, y para ello se han a desarrollado una serie de tres talleres, estos son autoconclusivos pero a su vez cada uno de ellos utiliza lo aprendido en el anterior, resultando en que una vez finalizados los tres se tenga una experiencia de realidad virtual completa creada con A-Frame en la que se introduce un objeto creado con BeetleBlocks y que puede ser controlada con un Micro:bit para moverse por ella.

El desarrollo y contenido de los talleres es el siguiente:
\begin{itemize}
\item \textbf{Taller 1}: Creación de un objeto 3D con Beetleblocks.\\
Este taller se centra en la creación de un objeto 3D con Bettleblocks, además se aprende a exportarlo y a darle el formato adecuado para usarlo en el siguiente taller.
\item \textbf{Taller 2}: Diseñar una experiencia VR con A-frame.\\
En este taller se aprende a usar A-Frame, creando un entorno de realidad virtual en el que se añade el objeto creado anteriormente con BeetleBlocks.
\item \textbf{Taller 3}: Micro:bit como interfaz de usuario para una experiencia de realidad virtual.\\
En este taller se convierte el Micro:bit en un controlador para la experiencia de realidad virtual creada con A-Frame, el Micro Bit permite moverse por la escena, mover la cámara y una pequeña interacción con el objeto.
\end{itemize}

\section{Taller 1 (Creación de un objeto 3D con Beetleblocks. )}
\label{sec:Taller1}
Este primer taller pretende enseñar a crear un objeto en 3D con BeetleBlocks y su accesible método de programación mediante bloques. Además en la segunda parte del taller se introduce Blender otra herramienta de diseño 3D que permite dar el formato correcto al objeto para usarlo en un entorno VR creado con A-Frame, que será el núcleo del segundo Taller\ref{sec:Taller2}.\\
El objetivo de este taller es introducir el diseño en 3D a alumnos de enseñanzas medias de tal forma que con una sesión, sean capaces de crear algún objeto básico en 3D y darle las herramientas necesarias para que puedan desarrollar algo más complejo en un futuro.
\subsection{ Introducción a Bettleblocks}
\label{subsec:T_Beetle}

Beettleblocks pone las cosas fáciles a la hora de crear objetos 3D, con este taller se pretende que un alumno con conocimientos muy básicos acerca de la programación consiga crear una figura en 3D, con unos pocos pasos.\\

Antes de comenzar a programar la primera figura se debe crear una cuenta en Bettleblocks para  de una forma accesible poder acceder a los proyectos guardados.
\begin{itemize}
 \item El primer paso es ir a la web de BeetleBlocks\footnote{http://BeetleBlocks.com} y en la esquina superior derecha pulsar sobre la opción \textit{Log in} para crear el usuario.
 \item Una vez hecho esto se puede comenzar a usar BeetleBlocks, para ello se debe pulsar en \textit{Run BeetleBlocks} como se ve en la Figura~\ref{figura:Run_Beetle}.\\
\end{itemize}
\begin{figure}[H]
    		\centering
    		\includegraphics[width=8cm, keepaspectratio]{img_b/run_beetle}
		\caption{Crear perfil e iniciar BeetleBlocks}
		\label{figura:Run_Beetle}
\end{figure} 

\clearpage
\subsection{El Primer Objeto }
\label{subsec:1_Beetle}

Una vez abierto BeetleBlocks se muestra una pantalla como la de la Figura~\ref{figura:Init_beetle}

\begin{figure}[H]
  \centering
  \includegraphics[width=14cm, keepaspectratio]{img_b/Bettleblocks}
  \caption{Inicio Beetle Blocks}
  \label{figura:Init_beetle}
\end{figure} 
A la izquierda se tiene el menú con los diferentes bloques ordenados por categorías. En el centro se encuentra el área de trabajo en el que se colocan los bloques, y a la derecha una previsualización en 3D del resultado de los bloques colocados en el área de trabajo en ella se puede observar un escarabajo, que resulta muy importante, porque indica la orientación actual respecto a los 3 ejes, siendo su cabeza la dirección hacia la que se está ``apuntando", en la Figura~\ref{figura:Orientacion} la orientación es hacia la parte positiva del eje \textit{x} y por lo tanto si se ordena un movimiento positivo con valor 1 el escarabajo avanzaría una casilla en ese eje Figura~\ref{figura:move}.\\
\begin{figure}[H]
 \centering
  \subfloat[Posición inicial]{
   \label{figura:Orientacion}
  \includegraphics[width=0.5\textwidth, height=0.3\textwidth]{img_b/beetle}}
    \subfloat[Movimiento en el eje x]{
   \label{figura:move}
   \includegraphics[width=0.5\textwidth, height=0.3\textwidth]{img_b/move}}
   \caption{Orientación y movimiento en Beetle Blocks}
 \label{figura:Beetle_headphones}
\end{figure}
Sabiendo esto ya se puede empezar a crear/programar el primer objeto.
A continuación se exponen las ordenes y funciones útiles para familiarizarse con Beetleblocks y crear un primer objeto:

\begin{enumerate}

	\item Dibujar una línea: usando la orden
	\includegraphics[width=0.2\textwidth]{img_b/Dibujar_linea}
 	que se encuentra en la pestaña de Shapes 
 	\item Creación de una variable: en la pestaña \textit{Variables} se encuentra la opción \textit{make a variable} que nos permite crear una variable global para utilizar.
	 \item Al crear una variable x, se le puede asignar un valor gracias al bloque \\
	 \includegraphics[width=0.22\textwidth]{img_b/Variables}
	 en el que se introduce el valor deseado.
	 \item Un elemento muy común en la programación son los bucles estos se representan en BeetleBlocks con el bloque  \includegraphics[width=0.08\textwidth]{img_b/Repetir}, para continuar con la creación de la figura se debe repetir el proceso de la creación de las líneas de una figura geométrica, en el hueco del bloque se inserta la variable creada, esto provoca que todos los bloques que son insertados a posteriori se repiten el número de veces que valor tenga la variable.
	 \item Dentro del bucle se deben insertar 2 bloques:
	 \begin{itemize}
	 \item El bloque 
	 \includegraphics[width=0.1\textwidth]{img_b/move_empty} este permite el movimiento y al haber ordenado previamente dibujar se ``pintará" una línea que tendrá la longitud igual al valor que insertemos en su hueco. En este  caso se debe insertar la variable y no un número concreto, más adelante se justifica este paso. El resultado por tanto debe ser el siguiente:
	 
	\includegraphics[width=0.12\textwidth]{img_b/move_x}
	\item El bloque 
	 \includegraphics[width=0.12\textwidth]{img_b/girar}
	 permite girar la dirección en la que está orientado el escarabajo, el valor que debe introducirse en cada hueco debe ser en grados. En este caso se quiere girar tantos grados como lados tenga la figura geométrica que se quiere conseguir, para hacerlo de una forma muy sencilla el bloque de división debe contener el número total de grados de un circulo entre los lados de la figura en este caso la variable x previamente creada, quedando de la siguiente manera 	\includegraphics[width=0.12\textwidth]{img_b/div} sólo queda combinar ambos bloques \includegraphics[width=0.22\textwidth]{img_b/giro_div}.
	\item Por último se combinan los tres bloques, tanto el bucle como los dos resultantes anteriores, el \textit{sprite} o conjunto de bloques final debería quedar como en la Figura~\ref{figura:loop}.
\begin{figure}[H]
    	\centering
    		\includegraphics[width=4cm, keepaspectratio]{img_b/bucle}
		\caption{Bloque combinado}
		\label{figura:loop}
\end{figure}
\end{itemize}
	 
	 \item Dos bloques que resultan muy útiles para crear cualquier objeto son los de la Figura~\ref{figura:Bloques} el primero inicia la serie de bloques anidados al hacer click sobre ellos, esto permite un control de la ejecución. Y el segundo que nos deja el plano en blanco, proporciona una manera de inicializar el escenario a su valor por defecto, para prevenir resultados no deseados.
	 
\begin{figure}[H]
 \centering
  \subfloat[Evento de Click]{
   \label{figura:Orientacion}
  \includegraphics[width=3cm, keepaspectratio]{img_b/click_event}}
    \subfloat[reset]{
   \label{figura:move}
   \includegraphics[width=1.5cm, keepaspectratio]{img_b/reset}}
   \caption{Bloques útiles}
 \label{figura:Bloques}
\end{figure}	 

	\item Finalmente, el resultado de la combinación de los diferentes bloques expuestos se puede ver en la Figura~\ref{figura:Figuras}, permite formar un sprite que dibuje figuras geométricas con el número de lados que se le da a la variable \textbf{x} creada.
\begin{figure}[H]
    		\centering
    		\includegraphics[width=5cm, keepaspectratio]{img_b/figuras}
		\caption{Sprite para crear figuras}
		\label{figura:Figuras}
\end{figure}
\end{enumerate}
\subsection{Formato }
\label{subsec:2_Beetle} 

El último paso por exponer es la exportación de la figura final de entre los diferentes formatos que ofrece Beetleblocks, ninguno es compatible con A-Frame, en la siguiente sección veremos como conseguirlo gracias a Blender, pero en este paso es necesario exportarlo en formato \textit{.stl}.

\subsection{ Blender}
\label{subsec:T_Blender}

Una vez que se ha creado un objeto con Beeetleblocks el paso final es conseguir que tenga una extensión \textit{.obj} que es la apropiada para poder usar el objeto en el siguiente taller, en el que mostrará la manera de crear una experiencia de realidad virtual con A-frame.De entre las múltiples maneras de conseguirlo, en este trabajo se ha optado por usar usar Blender un software OpenSource de diseño 3D.La pantalla de inicio de Blender se puede ver en la Figura~\ref{figura:Init_Blender}.\begin{itemize}
\item Los pasos a seguir para exportar nuestra figura en \textbf{\textit{.obj}} y \textbf{\textit{.mtl}} son los siguientes:
\begin{enumerate}

	 \item Borrar el cubo, posicionando el ratón encima y presionando    	\textbf{\textit{x}} para borrarlo.  
	 
	 \item Se pulsa \textit{espacio} y se introduce en el cuadro de texto \textbf{\textit{import stl}}, se importa la figura de Beetle Blocks previamente creada y exportada con un formato \textit{stl}.
	 
	 \item Se pulsa \textit{espacio} de nuevo y se introduce \textbf{\textit{export obj}} en el cuadro de texto, como se ve en la Figura~\ref{figura:Check}, se deben marcar las \textit{Checkboxes} 						\textbf{\textit{Write Normals, Write Materials}} y exportar el objeto a la ruta deseada, si todos los pasos se han realizado correctamente, deben aparecer dos nuevos archivos \textbf{\textit{xxx.obj}} y \textbf{\textit{xxx.mtl}}.
\end{enumerate}
\begin{figure}[H]
 \centering
  \subfloat[Blender]{
  \label{figura:Init_Blender}
   \includegraphics[width=10cm, height=5cm]{img/blender_0}}
    \subfloat[Checkboxes]{
      \label{figura:Check}
  \includegraphics[width=4cm, height=4.6cm]{img/export_obj}}
   \caption{inicio de Blender y exportación}
 \label{figura:Blender_0}
\end{figure}	
\end{itemize}
\clearpage

\section{Taller 2 (Creación de un entorno VR ) }
\label{sec:Taller2}

En este segundo taller se enseñará a crear una experiencia de realidad virtual con A-Frame, además se añadirá el objeto previamente creado con  BeetleBlocks en el primer taleer, y se indicaran los pasos a seguir para visualizar el escenario de A-Frame en un smartphone.
\subsection{Creación de entorno VR con A-Frame}
\label{subsec:T_Aframe}

Para crear la experiencia de realidad virtual con A-Frame el primer paso es crear un documento index.html y el repositorio en el que se van a incluir los archivos necesarios.
Todos los comandos de terminal descritos en este taller se basan en un terminal Linux, con los siguientes se procede a crear el directorio de la práctica y el archivo html.
\begin{verbatim}
mkdir A-Frame
cd A-Frame
makefile index.html
\end{verbatim}

A-Frame puede ser utilizado desde un documento plano de HTML sin la necesidad de instalar nada.Simplemente para empezar a usarlo se debe importar en la cabecera  de index.html de esta manera:

\begin{verbatim}

	<head>
    		<script src="https://aframe.io/releases/0.9.0/aframe.min.js">
    				</script>
\end{verbatim}


\subsection{Explorando A-Frame}
\label{subsec:Ex_Aframe}
Una vez se ha cargado la versión de A-Frame se puede dar paso a un primer acercamiento. Un ejemplo sencillo para aprender a usar A-Frame consiste en cargar un primitive, plantillas de elementos que están dentro del código de A-Frame, gracias a ellos se puede crear un cubo , un cilindro, una esfera \dots. de una forma muy sencilla.
A la hora de usarlos en el \textit{index.html} basta con nombrarlos como si se tratara de una entidad, a los primitives se le pueden dar diferentes propiedades.
Siempre que se carga una figura en A-Frame tiene que ser dentro de la escena,esta se identifica en el documento HMTL con $<$\textit{a-scene}$>$.

A continuación se expone un ejemplo, en el que se introducen una serie de primitives como un cubo y una esfera dentro de la escena de A-Frame, y el resultado puede verse en la Figura~\ref{figura:A_frame_ex}.
{\footnotesize
\begin{verbatim}
<body>
 <a-scene>
  <a-box position="-1 0.5 -3" rotation="0 45 0" color="#4CC3D9">
  </a-box>
  <a-sphere position="0 1.25 -5" radius="1.25" color="#EF2D5E">
  </a-sphere>
  <a-sky color="#ECECEC"></a-sky>
 </a-scene>
</body>
\end{verbatim}
}
\begin{figure}[H]
    		\centering
    		\includegraphics[width=15cm, keepaspectratio]{img/A_frame_ex}
		\caption{Cubo y esfera primitives en A-Frame}
		\label{figura:A_Frame-ex}
\end{figure}
Además es posible crear nuestros primitives propios, algo que se puede ver en la siguiente sección de este taller, para ello es necesario exportar un archivo JavaScript.

Ahora que ya se ha explicado la metodología para cargar objetos en A-Frame, el siguiente paso a realizar es cargar el objeto creado con BeetleBlocks, ya con el formato \textbf{\textit{.obj}} que se le ha dado previamente con Blender.
\clearpage
\begin{itemize}
\item El proceso para cargarlo en el index.html es el siguiente:
\begin{enumerate}

	 \item Se inicializan las variables \textbf{\textit{.obj}}, \textbf{\textit{.mtl}}, y \textbf{\textit{textura}}.  
	 
	 {\footnotesize
\begin{verbatim}
<a-entity 
 obj-model="obj: #crate-obj;" mtl="#crate-mtl" 
             material="src: #crate-texture">

</a-entity>.
\end{verbatim}
	}
	 
	 \item Se cargan el \textbf{\textit{.obj}}, \textbf{\textit{.mtl}}, y la  \textbf{\textit{textura}}.Para la textura vale cualquier \textbf{\textit{.jpg}}, es recomendable que se trate de algún tipo de imagen que sea una textura.En la propiedad  \textbf{\textit{src}} se indica la ruta de cada archivo a importar.A continuación se puede ver un ejemplo:
	 
	{\footnotesize
\begin{verbatim}
<a-assets>
 <a-asset-item id="crate-obj" src="models/cascos3.obj"></a-asset-item>
 <a-asset-item id="crate-mtl" src="models/cascos3.mtl"></a-asset-item>
 <img id="crate-texture" src="img/military-camouflage.jpg">
</a-assets>	

\end{verbatim}
	}
\end{enumerate}

\subsection{Animación básica con A-frame.}
\label{subsec:T_Aframe_Animacion}

A-Frame nos permite añadir algo de animación básica a nuestra figura, gracias a la importación de paquetes en JavaScript.

El ejemplo expuesto aquí consigue aportarle una animación al objeto que consiste en una rotación al hacer click sobre él, para hacerlo se debe importar el paquete aframe-animation-component.

Lo importamos en la cabecera $<$\textit{head}$>$ del documento de la misma forma que se hace con A-Frame.
	 {\footnotesize
\begin{verbatim}
<script src="https://rawgit.com/ngokevin/aframe-animation-component
  /master/dist/aframe-animation-component.min.js">

</script>
\end{verbatim}
}
Para usar la animación $<$\textit{a-animation}$>$ es necesario invocarla dentro del objeto, representado en A-Frame como $<$\textit{a-entity}$>$, de la siguiente manera:

	 {\footnotesize
\begin{verbatim}
<a-entity [...]>

 <a-animation attribute="rotation" begin="click"
 			 repeat="5" to="0 360 0">  </a-animation>
 
 <a-event name="mouseenter" scale="4 1 6">
 </a-event>
 
</a-entity>
\end{verbatim}
}

Como se puede observar uno de los atributos de $<$\textit{a-animation}$>$  es begin="click", este permite que la animación sólo se ejecute cuando se hace click sobre el objeto.
Al estar en un entorno de realidad virtual, no se dispone del ratón y lo que funciona sería el equivalente del es el centro de la mirada, para conseguir simular apuntar al objeto  con el puntero del ratón es necesario crear un cursor ``virtual" en el centro de la pantalla, que no es otra cosa que el centro de la perspectiva que tenemos en cada momento.
El cursor se crea una vez se define la posición inicial de la cámara, en este caso se le da un color rojo para que resalte con el fondo de la escena.

Una vez aclarado este punto la creación del cursor y centrar la cámara es muy sencillo, y debe hacerse dentro del objeto:
\begin{verbatim}
[...]
 <a-camera position="1.5 1 6.5">
 
  <a-cursor color="#FF0000">
  
 </a-camera>
</a-entity>
[...]
\end{verbatim}

El resultado final puede verse en la Figura~\ref{figura:A_Frame}

\begin{figure}[H]
    		\centering
    		\includegraphics[width=14cm, keepaspectratio]{img/A_Frame}
		\caption{Cursor en una escena de A-Frame}
		\label{figura:A_Frame}
\end{figure}

\subsection{Llevar la experiencia VR a un smartphone}
\label{subsec:T_smart}
Con todo esto se consigue crear un entorno de realidad virtual con A-Frame de forma local.Pero para visualizar un entorno de realidad virtual, es necesario un visor, la forma más rapida y sencilla de ver obetener uno, es a través de un smartphone, para exportar el index.html a internet y poder visualizarla desde el navegador web del teléfono se va a contar con la ayuda una utilidad llamada ngrok.

\begin{itemize}
\item Estos los pasos necesarios para usar ngrok y exportar la escena de A-Frame:
\begin{enumerate}
	\item En una terminal y estando en carpeta la raiz del proyecto, se lanza el servidor de forma local:
	\begin{verbatim}
	python -m SimpleHTTPServer 1234
	\end{verbatim}
	\item Instalar ngrok, simplemente descargando el .zip y descomprimiéndolo en la carpeta raíz.
	
	\item Después de esto es necesario ejecutarlo pasándo como argumento el puerto del servidor local previamente creado.
	
	\begin{verbatim}
	./ngrok http 1234
	\end{verbatim}
	
	\item Ngrok devuelve una pantalla, entre los datos que proporciona se encuentra la url pública de la aplicación, marcada en rojo en la Figura~\ref{figura:ngrok}. 
	\item Introduciendo esta url en un navegador compatible, por ejemplo Google Chrome, se puede visualizar la experiencia de A-Frame en un smartphone u otro dispositivo compatible.
	
\end{enumerate}
\end{itemize}

\end{itemize}
\begin{figure}[H]
    		\centering
    		\includegraphics[width=0.8\textwidth]{img/ngrok}
		\caption{Ngrok}
		\label{figura:ngrok}
\end{figure}


\clearpage 

\section{Taller 3(Micro Bit como IU en entorno VR)}
\label{sec:Taller3}

En este tercer taller se mostrará como convertir nuestro Micro Bit en un controlador para una experiencia de realidad virtual creada con A-Frame.

El propósito de este taller es partir del anterior a la hora de usar el controlador en la experiencia, pero no necesariamente es obligatorio ya que el Micro Bit debe funcionar en cualquier entorno de A-Frame que permita movimiento independientemente de como sea la experiencia en si.

Las funciones que llevará cabo el Micro Bit una vez finalizado el taller, serán las siguientes:

\begin{itemize}
\item Movimiento físico en la experiencia al pulsar B.
\item Movimiento de la cámara al pulsar A.
\item Interacción al pulsar los dos botones a la vez del Micro Bit.
\end{itemize}


\begin{figure}[H]
    		\centering
    		\includegraphics[width=15cm, keepaspectratio]{img/Microbit_functions}
		\caption{Funciones del Micro:bit}
		\label{figura:Microbit_functions}
\end{figure} 

Para programar el Micro:bit primero se debe preparar el entorno, como ya se indica en la introducción el lenguaje utilizado será python, o en su defecto micropython.
El sistema operativo será Linux, Micro:bit también dispone de compatibilidad con Windows mediante la instalación de un driver, esto será abordado en el anexo del trabajo.

Los pasos a realizar por tanto serán:
\begin{itemize}
\item Disponer de un editor de texto.
\item Instalar bitio.
\item Instalar pyautogui.
\end{itemize}

Con esto ya se dispone de un entorno apto para empezar a programar nuestra placa.

\subsection{Instalación de Bitio}
\label{subsec:Install_Bitio}

El primer paso es instalar Bitio, para ello lo primero que se debe hacer es ir a su repositorio de GitHub\footnote{https://github.com/whaleygeek/bitio}.

Como la propia documentación indica la mejor forma de usar bitio en un entorno educativo es copiar la carpeta `src/microbit' en el directorio Home del proyecto actual.

Con esto se consigue que automáticamente cualquier programa que esté en el mismo directorio acceda a la carpeta de bitio cuando se importe el paquete microbit, al principio del programa \textbf{.py}

\textit{import microbit}

Dentro de la carpeta `src' se ecuentran una serie de programas para probar las distintas funcionalidades de bitio.

La forma de probar si se ha instalado bitio correctamente es tan simple como hacer una prueba con uno de ellos.Tomando como prueba \textit{button.py} se obtienen estos valores en la terminal al ejecutar el programa.

\begin{verbatim}

python button.py

\end{verbatim}
\begin{verbatim}
No micro:bit has previously been detected
Scanning for serial ports
remove device, then press ENTER
scanning...
port[0]:COM1
found 1 device(s)
plug in device, then press ENTER
scanning...
port[0]:COM1
port[1]:COM6
found 2 device(s)
found 1 new device
selected:COM6
Do you want this device to be remembered? (Y/N)
connecting...
Your micro:bit has been detected
Now running your program
micro:bit connected - press button A to test
Button A pressed
Button A pressed
Button A pressed
\end{verbatim}

El funcionamiento de cualquier programa de bitio  es el siguiente primero escanea los dispositivos conectados a nuestro pc, sin el Micro:bit entre ellos, a continuación pide al usuario que lo conecte y establece la conexión con él que corresponde al puerto nuevo encontrado.
Una vez que el programa está corriendo la última línea que se encuentra es.

\textit{Now running your program}

En este caso el programa nos devuelve una línea de texto cada vez que se pulsa el botón \textbf{A}.


\subsection{Instalación de Pyautogui}
\label{subsec:Install_Pyauto}

A continuación se debe instalar pyautogui para poder correr código de python en el Micro:bit.

El método de instalación difiere un poco en función del sistema operativo que se utiliza, en este trabajo de fin de grado los test han sido tanto en Linux como en Windows 10.

Al igual que con bitio el método de instalción que se describe aquí esta basado en la propia documentación:

\textit{https://github.com/asweigart/pyautogui}

Para instalar pyautogui en Linux:
\begin{verbatim}
pip3 install python3-xlib
sudo apt-get install scrot
sudo apt-get install python3-tk
sudo apt-get install python3-dev
pip3 install pyautogui
\end{verbatim}

Con esto ya se cuenta con pyautogui totalmente funcional al importar el paquete al principio del programa mediante la línea.

\textit{import pyautogui}


Una prueba sencilla para saber si pyautogui es funcional es probar el programa testpy.py que se adjunta en este trabajo.
Su contenido es el siguiente.

\begin{verbatim}
import microbit
import pyautogui
while True:
	if microbit.button_a.was_pressed():
		microbit.display.show("PULSA A")
		screenWidth, screenHeight = pyautogui.size()
		pyautogui.moveTo(screenWidth / 2, screenHeight / 2)
		microbit.sleep(500)
		microbit.display.clear()
\end{verbatim}

La funcionalidad del programa es hacer centrar la posición de nuestro ratón cuando se pulsa A en el microbit, para saber si pyautogui esta correctamente instalado basta con lanzar este programa y ver si el puntero del ratón se desplaza al centro de la pantalla al pulsar A.


\subsection{Programación del Micro:bit}
\label{subsec:Prog_Microbit}

Una vez se tiene el entorno preparado y todas las herramientas instaladas se puede proceder a programar el Micro:bit y convertirlo en el controlador de la experiencia.

Como ya se hace referencia anteriormente en el trabajo, el punto de partida se corresponde con el siguiente repositorio de github.

\textit{https://github.com/sarehp/microbit-aframe}.

El objetivo del taller será optimizar este código base para crear un controlador con más funcionalidades.

A continuación se describe el estudio y realización de cada una de ellas correspondientes a la figura~\ref{figura:Microbit_functions}

\begin{itemize}
\item[A) ] Movimiento
\item[B) ] Control de la cámara.
\item[C) ] Interacción.

\end{itemize}

\Large
A) Movimiento \\
\normalsize
Para programar el movimiento dentro de A-Frame se tomó el código del repositorio de github y se le añadió la funcionalidad de centrar la cámara antes de comenzar el movimiento para facilitar la experiencia.
Esto esprogramado con pyautogui.

\begin{verbatim}
	screenWidth, screenHeight = pyautogui.size()
	pyautogui.mouseDown()
	pyautogui.moveTo(screenWidth / 2, screenHeight / 2)
	pyautogui.mouseUp()
\end{verbatim}
\begin{itemize}
\item Con la primera línea se guarda la resolución de la pantalla en dos variable una para el ancho y otra para el alto.
\item Se deja el ratón pulsado con la orden mouseDown, se hace esto para entrar en el control de la cámara en A-frame.
\item Se mueve el ratón al centro de la pantalla
\item Por último se suelta el botón izquierdo del ratón para salir del control de la cámara.
\end{itemize}

\clearpage
\Large
B) Interacción \\
\normalsize

La Siguiente función en ser implementada es la interacción, en este caso su programación es muy sencilla.

La interacción que fue creada en el anterior taller consistía en una pequeña animación del objeto 3D dentro del escenario creado por A-Frame. La animación es ejecutada mediante un click del ratón cuando se enfoca directamente al objeto.

Por tanto la función a implementar en el Micro:bit es el click del ratón.
Hay una función en pyautogui que permite esta orden.

\begin{verbatim}
pyautogui.click()
\end{verbatim} 

El método de detección que ha sido elegido en este caso es la pulsación simultanea de los dos botones para hacer click.
Para capturar una pulsación de un botón Micro:bit posee una una función específica para cada uno por lo que en el bloque if se deberá incluir las dos en un \textit{and} de la siguiente forma:

\begin{verbatim}
microbit.button_a.is_pressed() and microbit.button_b.is_pressed():
\end{verbatim}

\Large
C) Control de la Cámara \\
\normalsize

El primer paso para programar el control de la cámara fue estudiar las diferentes funciones que ofrece pyautogui a la hora de poder interactuar con la pantalla y el ratón.

Para poder implementar el movimiento de la cámara con el accelerómetro del Micro:bit, primero es necesario entender como se maneja la cámara en A-Frame con un ratón común.Para mover la cámara es necesario pulsar dentro del escenario de A-Frame y a continuación desplazar el ratón en la dirección deseada sin soltar el botón izquierdo del ratón.

Por tanto lo que se ha hecho en este caso es mapear el movimiento del ratón por la pantalla en base a los valores que ofrece el acelerómetro del Micro:bit.
Los diferentes pasos que se han seguido son los siguientes.
 
En lo relativo a la pantalla se extrae la resolución. Como se ve en la figura~\ref{figura:Resolutions} existen multitud de resoluciones posibles en función de la pantalla en la que se ejecuta la experiencia de A-Frame, en concreto en la realización de este trabajo de fin de grado se disponía de una pantalla 4k con una resolución de 3840x2160 pixeles, esta no es una resolución muy común en la actualidad, por ello aquí se describirá la programación de la funciónalidad en base a una pantalla Full HD (1920x1080)

\begin{figure}[H]
    		\centering
    		\includegraphics[width=15cm, keepaspectratio]{img/resolutions}
		\caption{Resoluciones}
		\label{figura:Resolutions}
\end{figure} 

Tomando como base por tanto la resolución Full HD tenemos 1920 pixeles de ancho y 1080 pixeles de alto.
Ahora se necesita saber como funciona el acelerómetro del Micro:bit.
Con la función \textit{microbit.accelerometer.get\_ x()} y \textit{microbit.accelerometer.get\_ y()} se extraen los valores del acelerómetro
los cuales van de 1000 a -1000 en cada uno de los ejes como se ve en la figura~\ref{figura:acc_vals}.

\begin{figure}[H]
    		\centering
    		\includegraphics[width=10cm, keepaspectratio]{img/acc_vals}
		\caption{Valores del acelerómetro}
		\label{figura:acc_vals}
\end{figure} 

Como el objetivo es mapear el movimiento del ratón con los valores del acelerómetro solo se necesitan dos ejes, debido a que la pantalla es un plano de dos dimensiones.

Una vez se tiene clara la medida del ancho de la pantalla en la que se ejecuta la experiencia de realidad virtual y los valores máximos del acelerómetro el siguiente paso es mover la cámara.

Como se puede ver anteriormente para mover la cámara en A-Frame es necesario mover el ratón mientras se mantiene pulsado el botón izquierdo del mismo para hacer esto, son necesarias estas dos funciones de pyautogui.

\begin{verbatim}
pyautogui.mouseDown()
pyautogui.moveRel(x, y)
\end{verbatim}

Con \textit{pyautogui.mouseDown()} se consigue dejar pulsado el ratón y con \textit{pyautogui.moveRel(x,y)} se mueve el ratón en función de su posición actual en la pantalla.

Una vez se sabe esto, basta con implementar un método de sensibilidad en el acelerómetro parecido al ya creado con el movimiento físico.
\begin{verbatim}
x = microbit.accelerometer.get_x()
y = microbit.accelerometer.get_y()
			
if x > SENX:
	pyautogui.moveRel(Height*x, None)
elif x < -SENX:
	pyautogui.moveRel(Height*x, None)			
if y > SENY:
	pyautogui.moveRel(None, y*Width)
elif y < -SENY:
	pyautogui.moveRel(None, y*Width)

\end{verbatim}

Con este código se consigue mover el ratón en todas las direcciones en base a los valores del acelerómetro en el \textbf{eje x} y el \textbf{eje y}.
Las variables \textit{SENX} y \textit{SENY}, representan la sensibilidad en los ejes del acelerómetro del Micro:bit, en este caso fueron fijadas a 180 y 280 respectivamente para prevenir movimientos, de una forma parecida al Threshold, en la anterior función implementada en el Micro:bit del movimiento.

Por último se puede observar que el valor del acelerómetro es multiplicado por dos variables \textbf{Height} y \textbf{Width}, Estas son variables que ayudan a graduar el grado de sensibilidad del movimiento del ratón y son resultado de la división del ancho y el alto de la resolución de la pantalla usada, por un factor 
multiplo de los valores ancho y alto de una pantalla Full HD.Para las pruebas realizadas en este proyecto su valor es el siguiente.
\begin{verbatim}
screenWidth, screenHeight = pyautogui.size()
Factor_y = 1920*6 
Factor_x = 1080*6

Width = screenWidth / Factor_y 
Height = screenHeight/ Factor_x
\end{verbatim}

Cambiando el valor de estas variables es posible ajustar la sensibilidad del movimiento en función de la pantalla usada, basta con cambiar el múltiplo por  uno menor en este caso fue 6 debido a que la pantalla era 4k y la densidad de píxeles era muy elevada, despumes de diversas pruebas se confirmó como un valor apropiado para tener un control óptimo e la experiencia, en el que la cámara no se mueva excesivamente rápido.


\clearpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% CONCLUSIONES %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\chapter{Conclusiones}
\label{chap:conclusiones}

En la última parte de este trabajo de fin de grado se analiza la consecución de los objetivos propuestos. los conocimientos aprendidos durante el grado que han sido aplicados, los conocimientos aprendidos por el alumno en la realización de este mismo así como los trabajos futuros en base a posibles ideas o funcionalidades a implementar en un futuro.

\section{Consecución de objetivos}
\label{sec:consecucion-objetivos}

En el capitulo~\ref{chap:Obj} se exponen una serie de objetivos:
\begin{enumerate}
\item Visibilidad de las experiencias de realidad virtual en la educación
\item Conseguir crear una experiencia VR propia
\item Implementar una funcionalidad del Micro:bit en el entorno de A-Frame 
\end{enumerate}

Para la consecución del primer objetivo se llevo a cabo una descripción de la realidad virtual así como las posibles utilidades y aplicaciones posibles para mejorar la educación en diferentes ámbitos ayudando así a la introducción de una parte práctica en el aprendizaje de los alumnos lo que conlleva una mayor retención de los conocimientos.

Respecto al objetivo de conseguir crear una experiencia de realidad virtual propia y a que a su vez sea posible para alumnos que vayan a acceder a la universidad, es conseguido gracias a BeetleBlocks y A-Frame dos herramientas simples de entender basadas en la programación por bloques y javascript respectivamente pero que ofrecen múltiples posibilidades de creatividad y en el caso de A-Frame la creación de experiencias virtuales a través de la docencia.

Por último la parte más compleja como es la programación del Micro:bit usando micropython para transformarlo en el controlador de la experiencia previamente creada con A-Frame. Como ya se ha dicho es la parte más compleja a la hora de ser impartida a alumnos en fase de acceso a la universidad ya que es necesario una serie de conocimientos de python, por tanto el tercer taller se ha orientado en un guión guiado que ayude ala comprensión con pequeñas partes prácticas para asentar las bases de la programación.

\section{Aplicación de lo aprendido}
\label{sec:aplicacion}

Para la realización de este trabajo de fin de grado las principales asignaturas relacionadas con el mismo son :

\begin{enumerate}
  \item INGENIERIA DE SISTEMAS DE INFORMACION
  \item DESARROLLO DE APLICACIONES TELEMATICAS
  \item SERVICIOS Y APLICACIONES TELEMATICAS
\end{enumerate}

En ellas el alumno aprendió la programación con python, javascript además de conocimientos y aplicación de utilidades relacionadas con HTML5.

\section{Lecciones aprendidas}
\label{sec:lecciones_aprendidas}

Los conocimientos aprendidos por el alumno en este trabajo de fin de grado corresponden a la creación de objetos en 3D, la creación de experiencias de realidad virtual así como la programación del Micro Bit.

Con esto se puede concluir que toda la parte práctica de los talleres ha servido a su vez para que el alumno realizara una labor de estudio y aprendizaje de las tecnologías aplicadas, para la creación posterior de los talleres didácticos.

\clearpage
\section{Trabajos futuros}
\label{sec:trabajos_futuros}

En este apartado se detallan las posibles mejoras e ideas que podrían ser útiles en un futuro:
\begin{itemize}
\item Mejorar la animación del objeto 3D ya sea usando un Software externo o explotando las posibilidades de A-Frame.
\item Aumentar el número de funcionalidades del Micro Bit dentro de A-Frame, usando eventos de movimiento como sacudirlo o el uso de la brújula interna.
\item Introducir alguna funcionalidad extra de A-Frame en el segundo taller como por ejemplo la realidad Aumentada.
\item Mejoras la experiencia programando un sencillo juego que haga uso del Micro Bit dentro de A-Frame, esto podría contemplarse como un trabajo mucho más elaborado si se quieren introducir más de un Micro Bit y aumentar la complejidad del juego en cuestión.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%1%%%%%%%%%%%%%%%%%%%%%%%%%
% BIBLIOGRAFIA %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage

% Las siguientes dos instrucciones es todo lo que necesitas
% para incluir las citas en la memoria
\bibliographystyle{abbrv}
\bibliography{memoria}  % memoria.bib es el nombre del fichero que contiene
% las referencias bibliográficas. Abre ese fichero y mira el formato que tiene,
% que se conoce como BibTeX. Hay muchos sitios que exportan referencias en
% formato BibTeX. Prueba a buscar en http://scholar.google.com por referencias
% y verás que lo puedes hacer de manera sencilla.
% Más información: 
% http://texblog.org/2014/04/22/using-google-scholar-to-download-bibtex-citations/



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% APÉNDICE(S) %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\cleardoublepage
\appendix
\chapter{Guía de uso Beetleblocks}
\label{chap:apen}
BeetleBlocks tiene la mayoría de categorías en común con Scratch. Cualquiercategoría, se puede ocultar pulsando el botón derecho.SI se quiere hacer un reinicio de un bloque se debe pulsar click derecho en el área de trabajo y selecionar "show primitives".
Por último todas las letras \textbf{``n"} de esta guía corresponden a un valor numérico y los puntos suspensivos \textbf{(\dots)} a un cuadro de entrada de texto\\

\section{Movimiento}
\label{sec:Movimiento}
\setlength{\columnsep}{0.1in}
 \begin{multicols}{2}
 \begin{itemize}
   \item Go home
   \item move (n) \# Se Mueve n veces.
   \item rotate z(eje) by (n)
   \item go to x:(n)y:(n)z:(n)
   \item set x(eje) to (n)
   \item change absolute x(eje) by (n)
   \item set z(eje) rotation to (n)
   \item point to x:(n)y:(n)z:(n)
   \item x(eje) position
   \item z(eje) rotation
   \item push position
   \item pop position
   \item set scale to (n)
   \item change scale by (n)
   \item scale
 \end{itemize}
 \end{multicols}
\clearpage

\section{Control}
\label{sec:Control}
 \setlength{\columnsep}{0.1in}
 \begin{multicols}{2}
 \begin{itemize}
    \item Reset \# Resets all rendered graphics.
    \item When Green Flag clicked \# Runs the code below it when clicked.
    \item When space($\downarrow$) key pressed
    \item When I receive ($\downarrow$)
    \item Broadcast ($\downarrow$)
    \item ~[Checkbox] message
    \item Warp
    \item Wait (n) secs \# Waits for a period of time.
    \item Wait until $<$boolean$>$
    \item Forever \# Runs code inserted into it forever.
    \item Repeat (n) \# Repeats code inserted into it a selected amount of times.
    \item Repeat until $<$boolean$>$ \# Repeats code inserted into it until a specified thing happens.
    \item If $<$boolean$>$ \# If something specified happens it will run the inserted code.
    \item If $<$boolean$>$ else \# If something specified happens it will run the code inserted into the if area but if it does not happen it will run the code inserted into the else area.
    \item Report [string]
    \item Stop all($\downarrow$) \# Stops the specified $\downarrow$.
    \item Stop all but this script \# Stops the script specified in the $\downarrow$
    \item Run (...)
    \item Launch (...)
    \item Call (input)
    \item Run (...) w/continuation
    \item Call (...) w/continuation
    \item Pause all \# Pauses rendering.
	\end{itemize}
	\end{multicols}
\section{Colores}
\label{sec:Colores}
	\begin{itemize}
	\item Set hue($\downarrow$) to (n) \# Sets selected option to selected n
    \item Change hue($\downarrow$) by (n) \# Changes selected option by selected n
    \item Color ($\downarrow$)
	
	\end{itemize}
\clearpage	

\section{Figuras}
\label{sec:Figuras}
\setlength{\columnsep}{0.1in}
 \begin{multicols}{2}
 \begin{itemize}
    \item Cube Dim. (n)
    \item Cuboid l: (n) w: (n) h:(n)
    \item Sphere Dia. (n)
    \item Tube l:(n) outer: (n) inner: (n)
    \item Text [string] H: (n) W: (n)
    \item 2D text [string] size: (n)
    \item Start drawing lines($\downarrow$) \# Starts drawing the specified $\downarrow$ option.
    \item Stop drawing \# Stops drawing.
    \item Start extruding curves($\downarrow$)
    \item Stop extruding \# Stops extruding.
    \item Set extrusion Dia. to (n)
    \item Change extrusion Dia. by (n)
 
\end{itemize}
\end{multicols}

\section{Funciones}
\label{sec:Funciones}
\setlength{\columnsep}{0.1in}
 \begin{multicols}{2}
 \begin{itemize}
    \item Request user ... [text] \# Requests ...ted text
    \item ~[~[Checkbox]] answer
    \item ~[Checkbox] mouse x
    \item ~[Checkbox] mouse y
    \item $<$mousedown$>$
    \item $<$key space($\downarrow$) pressed?$>$
    \item reset timer
    \item ~[Checkbox] timer
    \item ~[http://(url)]
    \item $<$turbo mode?$>$
    \item set turbo mode to $<$boolean input$>$ \# Sets turbo mode to inputted boolean
    (current date($\downarrow$))
 
 \end{itemize}
 \end{multicols}
 
\section{Crear una variable}
\label{sec:Crear una variable}

Cuando se pulsa en el botón de crear una variable se despliega el cuadro de creación en el se introduce el nombre de la variable a crear y se puede elegir si esta variable puede ser usada por todos los sprites o solo para algunos en concreto.\\
\clearpage
\Large Variables
\normalsize
\setlength{\columnsep}{0.1in}
 \begin{multicols}{2}
 \begin{itemize}

    \item set ($\downarrow$) to (...) \# Sets inputted variable to inputted text/n
    \item change ($\downarrow$) by 1(n) \# Changes inputted variable by inputted n
    \item show variable ($\downarrow$) \# Shows the inputted variable
    \item hide variable ($\downarrow$) \# Hides the inputted variable
    \item script variables a(...) $<$increase$>$
    \item list (...) $<$increase$>$
    \item (...) in front of list
    \item item 1($\downarrow$) of list
    \item all but first of list
    \item length of list
    \item list contains thing(...)
    \item add thing(...) to list \# Adds inputted text/n to the list
    \item delete 1($\downarrow$) of list \# Deletes inputted item from the list
    \item insert thing(...) at 1($\downarrow$) of list \# Inserts inputted text/n in the inputted area of the list
    \item replace item ($\downarrow$) of list with(...) \# Replaces inputted item of list with inputted item
 \end{itemize}
 \end{multicols}
 \section{Crear un bloque}
\label{sec:Crear un bloque}

 La sección de crear un bloque consta de uno único hasta que el usuario crea alguno.Para crear un bloque, es necesario hacer click en el botón correspondiente, esto abre un cuadro de dialogo que ofrece las siguientes opciones:
 \begin{enumerate}
\item Selección de categoría, el color de los bloques es acorde a la categoría elegida.
	
\item Editar el nombre del bloque  creado, esté queda escrito en el propio bloque. 

\item Selección el tipo de bloque entre tres: Command, Reporter y Predicate

\item Opción de hacer el bloque visible/disponible para el sprite actual o para el área de trabajo al completo.
 \end{enumerate}
\section{Operadores}
\label{sec:Operadores}
\setlength{\columnsep}{0.1in}
\begin{multicols}{2}
\begin{itemize}

    \item(n) + (n)
    \item(n) - (n)
    \item(n) x (n)
    \item(n) / (n)
    \item(n) mod (n)
    \item round (n)
    \item sqrt($\downarrow$) of (n)
    \item pick random (n) to (n)
    \item(...) $<$ (...)
    \item(...) = (...)
    \item(... $>$ (...)
    \item $<$boolean$>$ and $<$boolean$>$
    \item $<$boolean$>$ or $<$boolean$>$
    \item not $<$boolean$>$
    \item $<$true$>$
    \item $<$false$>$
    \item join (text)|(text)|(text) $<$ $>$
    \item split (text) by ($\downarrow$)
    \item letter (n) of (text)
    \item length of (text)
    \item unicode of (letter)
    \item unicode (n) as a letter
    \item is (...) a ($\downarrow$) ?
    \item is (...) identical to (...) ?
    \item JavaScript function 

\end{itemize}
\end{multicols}


\begin{figure}[H]
  \subfloat[Colores]{
   \label{f:Colores}
  \includegraphics[width=0.3\textwidth]{img/Bcolors}}
\end{figure} 
\clearpage

\begin{figure}[H]
 \centering
  \subfloat[Movimiento]{
   \label{f:motion}
    \includegraphics[width=0.3\textwidth ]{img/Bvariables}}
  \subfloat[Control]{
   \label{f:Control}
    \includegraphics[width=0.3\textwidth, height=0.75\textwidth]{img/Bcontrol}}
    \subfloat[Operadores]{
   \label{f:Operadores}
    \includegraphics[width=0.3\textwidth, height=0.75\textwidth]{img/Boperators}}
  
 \caption{Bloques Beetle Blocks A}
 \label{f:animales}
\end{figure} 

\begin{figure}[H]
 \centering
  \subfloat[Colores]{
   \label{f:Colores}
  \includegraphics[width=0.3\textwidth, height=0.4\textwidth]{img/Bmotion}}
    \subfloat[Funciones]{
   \label{f:Funciones}
    \includegraphics[width=0.3\textwidth, height=0.4\textwidth]{img/Bsensing}}
    \subfloat[Figuras / Formas]{
   \label{f:Formas}
    \includegraphics[width=0.3\textwidth, height=0.4\textwidth]{img/Bshapes}}
   \caption{Bloques Beetle Blocks B}
 \label{f:animales}
\end{figure}

\clearpage


\chapter{Auriculares en Beetle Blocks}
\label{chap:apen2}
En este segundo apéndice se explica el proceso de desarrollo y creación de los auriculares descritos en la práctica de BeetleBlocks.
\end{document}
